[ { "title": "H2 Databse", "url": "/posts/h2-databse/", "categories": "", "tags": "", "date": "2023-06-19 00:00:00 +0900", "snippet": "" }, { "title": "[백준] 11726 2xn 타일링(Python)", "url": "/posts/BOJ-11726/", "categories": "백준", "tags": "백준, algorithm, DP, 다이나믹 프로그래밍, 2xn 타일링, BOJ", "date": "2023-01-03 00:00:00 +0900", "snippet": "해당 게시글에서는 [백준] 11726 2xn 타일링 문제를 해설하고 Python을 이용하여 풀고자 한다.🤔 접근법문제 풀이 방식을 빠르게 알고싶다면 💡문제 풀이 부분 부터 봐주세요 :)11726번 문제는 DP(다이나믹 프로그래밍)에 대한 문제로 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법하는 방식의 알고리즘이다.현재 바킹독의 알고리즘 문제집을 참고하여 알고리즘 별로 문제를 풀고있기 때문에 이 문제가 DP 문제라는 것을 알고 있었다.하지만 해당 문제를 처음 접했을 때는 DP 문제라는 게 도저히 와닿지 않았다.결과적으로 혼자 풀긴 했지만 만약 DP 문제인 것을 몰랐더라면? 나는 못 풀었을 것이라고 생각한다.DP 문제의 경우 제시한 상황에 대한 규칙, 즉 점화식만 알면 어렵지 않기 때문에 직접 손으로 그려가며 규칙을 찾으려고 했다.N번째 직사각형의 경우에 N-1번째, N-2번째, N-3번째, … 등과 어떤 규칙이 있는지 찾아보려고 했지만 도저히 찾을 수 없었다.이러한 고민을 계속 하다가 든 생각이 '왜 굳이 기하적으로 생각하고 있지? 직사각형의 가로의 길이를 1과 2의 조합으로 나누면 되지 않나?'었다.💡 문제 풀이즉, 2xn 크기의 직사각형을 1x2, 2x1 타일로 채우는 방법의 수는 직사각형의 가로를 1과 2의 조합으로 나누는 경우와 동일하다!이때 1(2x1 타일)과 2(1x2 타일)로 나누는 것은 2x1타일이 들어갈 자리와 1x2 타일이 들어갈 자리를 분배하는 것을 의미한다.예를 들어 n이 3이라고 하면, 3을 1과 2의 조합으로 다음과 같이 나눌 수 있다. 1+1+1 2+1 1+21의 위치에는 2x1의 타일을, 2의 위치에는 1x2의 타일을 넣으면 되는 것이다.사실 1, 2, 3 더하기 문제와 접근 방식이 동일한 문제였다. 해당 문제를 풀었다면 유사한 방식으로 접근하면 된다.그렇다면 이제 점화식을 어떻게 작성할 것인가? 정답을 알기 전에 다음 이미지를 통해 직접 규칙을 찾기를 바란다.위 이미지를 통해 규칙을 찾기 어렵다면 아래 이미지도 참고하자!부연 설명을 하자면, 앞서 2xn 직사각형을 타일링 하기 위해선 n을 1과 2의 조합으로 나눠야 된다고 했고, 그럼 모든 경우에 대해 숫자의 끝은 1 아니면 2일 것이다. 끝이 1인 경우는 앞에 있는 숫자의 합이 n-1인 경우, 즉 앞부분은 2x(n-1) 타일링이 됐음을 의미 끝이 2인 경우는 앞에 있는 숫자의 합이 n-2인 경우, 즉 앞부분은 2x(n-2) 타일링이 됐음을 의미2xn 타일링은 끝이 1인 경우와 끝이 2인 경우의 합인, 2x(n-1) 타일링 + 2x(n-2) 타일링인 것이다.이를 코드로 나타내면 다음과 같다.dp[i] = dp[i-1] + dp[i-2]📂 코드위 문제 풀이 방식을 통해 해당 문제를 풀어낸 필자의 코드는 다음과 같다.N = int(input())dp = [0, 1, 2]for i in range(3, N+1): dp.append(dp[i-1]+dp[i-2])print(dp[N]%10007)" }, { "title": "[Trabot] 오픈소스 딥러닝 챗봇 Kochat demo 실행 에러 해결", "url": "/posts/kochat-demo/", "categories": "Trabot", "tags": "오픈소스, opensource, 딥러닝, 챗봇, 프레임워크, kochat, demo, 한국어", "date": "2022-12-19 00:00:00 +0900", "snippet": "지난 게시글에서는 Kochat을 활용한 프로젝트인 Trabot에 대해서 설명했다.Trabot 프로젝트의 레거시 코드를 수정하기 위해, 다시 Kochat을 실행하기 위한 준비를 해야 한다.과거에도, 현재에도 Kochat 환경설정을 하는데 매우 애를 썼기 때문에 미래에서라도 이를 방지하고자 demo 실행 과정에 대한 기록을 하고자 한다.Kochat demo 실행 사이트에 설명이 잘 돼있으니 전반적인 내용은 해당 사이트를 참고하도록 하자. 필자는 위 사이트대로 진행하면서 문제가 발생한 부분만 추가적으로 기록할 것이다.🤖 Kochat 환경설정먼저 Kochat github에 들어가 repo를 clone한다.clone이 끝난 후에 해당 폴의 하위 폴더인 demo에 들어가면 application.py 파일이 있는데, 이게 Kochat을 사용하기 위한 서버 실행 코드이다.우선 Kochat 프로젝트를 사용하기 위한 가상환경을 생성하자.참고로 현재 필자의 개발환경은 다음과 같다. pycharm: 2022.2.4 pip: 22.3.1 JDK: 19.0.1 Anaconda3: 2022.10(Python 3.9.13 64-bit) _jpype.cp37-win_amd64.pyd venv python: 3.71️⃣ 가상환경 설정Anaconda가 문제인 건지, Kochat이 문제인 건지 왠지 모를 이유로 Pycharm에서 가상환경 연결이 잘 안 됐다. 이런 경우에는 과감히 VScode 같은 다른 개발 환경으로 넘어가자.필자는 데스크탑에서는 파이참으로 실행이 됐지만, VScode는 실행되지 않았다… (진짜 왜 그런지 모름)2️⃣ 라이브러리 설치개발자가 작성해둔 requirements.txt에 작성된대로 라이브러리를 설치하고 application.py를 실행하면 라이브러리의 버전과 관련한 에러가 발생한다.따라서 필자는 다음과 같이 requirements.txt 파일을 수정했다.matplotlib==3.2.1pandas==1.0.4gensim==3.8.3konlpy==0.5.2numpy==1.18.5joblib==0.15.1scikit-learn==0.23.1pytorch-crf==0.7.2requests==2.24.0flask==1.1.2jinja2&lt;3.1.0itsdangerous==2.0.1werkzeug==2.0.3tweepy==3.10.0이후 pip install -r .\\requirements.txt를 다시 하자.3️⃣ java.nio.file.InvailidPathException 에러이번에 데모 실행하면서 제일 난감했던 에러였다.위에서 게시한 블로그에도 같은 에러가 있었지만, 똑같이 설정해도 추가로 발생하는 에러이다.해결 방법은 아래와 같이 하면 된다.먼저 자신의 개발환경 디렉토리로 이동하고 다음 경로에 있는 파일을 찾자.\\Lib\\site-packages\\konlpy\\jvm.py해당 파일에 있는 아래 코드에서 *를 모두 없애자.folder_suffix = [ # JAR '{0}', # Java sources '{0}{1}bin', '{0}{1}*', # Hannanum '{0}{1}jhannanum-0.8.4.jar', # Kkma '{0}{1}kkma-2.0.jar', # Komoran3 '{0}{1}aho-corasick.jar', '{0}{1}shineware-common-1.0.jar', '{0}{1}shineware-ds-1.0.jar', '{0}{1}komoran-3.0.jar', # Twitter (Okt) '{0}{1}snakeyaml-1.12.jar', '{0}{1}scala-library-2.12.3.jar', '{0}{1}open-korean-text-2.1.0.jar', '{0}{1}twitter-text-1.14.7.jar', '{0}{1}*']거의 4시간 정도 싸운 후에 해결한 거 같다…이 외에도 자바 관련 에러가 굉장히 많았는데 해결 됐음에도 왜 해결됐는지 이유조차 모르겠다." }, { "title": "[Trabot] Kochat을 활용한 여행지 추천 챗봇 개발기", "url": "/posts/trabot-what/", "categories": "Trabot", "tags": "오픈소스, opensource, 딥러닝, 챗봇, 프레임워크, kochat, demo, 한국어", "date": "2022-12-17 00:00:00 +0900", "snippet": "🏳 시작하기에 앞서…갑자기 Kochat Demo 게시글을 작성하게 된 계기에 대해 말하고자 한다.나는 빅데이터AI를 활용한 여행지 추천 챗봇서비스를 주제로 2021 한이음 프로젝트에 참여했으며 입선했다.하지만 학업과 동시에 프로젝트를 진행하면서 시험 기간과 프로젝트 마무리 기간이 겹치게 돼 프로젝트를 깔끔하게 마무리 하지 못했으며, 이에 대한 아쉬움을 늘 가지고 있었다. 또 과거에 비해 지금의 나는 성장했기 때문에, 그때 구현하지 못했던 것을 구현할 수 있을 거 같다는 자신감이 생겼다.그래서 이번 기회에 기존의 코드를 개선하고 필요한 기능을 추가 구현하고자 다짐했다.✈ Trabot이란?Trabot은 우리 팀이 한이음에서 개발한 챗봇 어플리케이션이다. 이는 ‘여행’을 의미하는 Travle과 Chatbot을 결합한 것으로, 여행에 관련한 챗봇을 의미한다.해당 어플리케이션의 주된 목표는 사용자가 Trabot에게 원하는 여행지의 지역, 테마, 코스추천 등의 키워드를 입력하면, Trabot이 키워드에 관련된 여행지를 추천해주는 것이다. 사용자는 본인이 원하는 여행지를 손쉽게 찾을 수 있다는 장점이 있다.왜 이러한 아이디어를 생각했냐면, 필자는 mbti에서 P 성향이 있어 여행을 갈 때 어디를 갈지, 무엇을 할지, 어떤 걸 먹을지 등 여행지를 찾는 과정이 너무 귀찮았다. 그래서 누군가가 내가 원하는 여행지를 찾아주면 정말 좋겠다고 생각했다. 이런 생각에서 파생된 게 바로 Trabot이다!❓ 어떻게 개선할 것인가?그렇다면 이전 한이음 프로젝트 때는 어떻게 진행한 것인가?이때는 여행지를 추천해주기 위한 정보를 대한민국 구석구석 사이트에서 직접 동적 크롤링을 하여 챗봇에서 출력해주려고 했다.하지만 이 방법은 너무 오래 걸렸다… 애초에 여행지를 찾기 위해 페이지를 클릭하고, 여행지 상세 정보를 클릭하는 등 동적 크롤링 시간이 매우 오래 걸렸다. 그래서 당시 멘토님께서 추천해주신 방식이 크롤링한 정보를 DB에 저장해놓고 여행지를 출력할 때는 DB에 저장된 정보를 출력하는 것이었다.그래서 우린 이 방식을 채택을 했고 이대로 프로젝트를 마무리 했었다.하지만 지금 와서 생각해보니, DB의 정보를 계속 갱신해주지 않으면 사용자에게 최신의 정보를 추천해줄 수 없으므로 매우 수동적이며 좋지 않은 코드라고 생각한다. 또 크롤링으로 계속 갱신을 하기에는 효율성이 부족하다. 그래서 이번 기회에는 해당 기술을 개선하고자 했다.당시에 우리 팀은 TourAPI와 같이 한국관광공사에서 제공해주는 openAPI가 있는 것을 알았지만, 이를 이용할 수준이 되지 않았다. 시도 했지만 실패하여 위에서 언급한 방식을 그대로 이어갔다.하지만 이제는 할 수 있을 거 같고, 못할 거 같더라도 하고자 하는 의지가 생긴다. 그래서 이번엔 정말 openAPI를 이용해 사용자에게 더욱 최신의 정보를 제공할 수 있는 Trabot을 개발하고자 한다.또 기회가 된다면 서버 배포까지 할 수 있기를 희망한다.🔥 마무리이번 기회에 느꼈다. 프로젝트를 다시 진행하기 위해 Kochat 코드를 보는데 정말 새롭게 보는 코드 같았다. 내가 짠 코드도 정말 처음 보는 코드라는 생각이 들었다. 기록이라도 해놨으면 다시 이해하는 게 어렵지 않을텐데 당시 나는 기록의 중요성을 하나도 몰랐다.그래서 이번에 다시 시작할 때는 내가 짠 코드, 프로젝트 관련 지식 등에 대해 자세히 기록하고자 한다.잘 기록해서 유사한 프로젝트를 진행하려는 사람, 우리 팀원, 미래의 나에게 도움을 주고 싶다👊" }, { "title": "[백준] 14051 퇴사(Python)", "url": "/posts/BOJ-14501/", "categories": "백준", "tags": "백준, algorithm, DP, 다이나믹 프로그래밍, 퇴사, BOJ", "date": "2022-12-16 00:00:00 +0900", "snippet": "해당 게시글에서는 [백준] 14501 퇴사 문제를 해설하고 Python을 이용하여 풀고자 한다.🤔 접근법문제 풀이 방식을 빠르게 알고싶다면 💡문제 풀이 부분 부터 봐주세요 :)필자는 본인의 힘으로 해당 문제를 풀지 못했다. 따라서 이후에 유사한 문제를 볼 때 기억이 더 잘 나도록 블로깅을 하려고 한다.14501번 문제는 DP(다이나믹 프로그래밍)에 대한 문제로 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법하는 방식의 알고리즘이다.현재 바킹독의 알고리즘 문제집을 참고하여 알고리즘 별로 문제를 풀고있기 때문에 이 문제가 DP 문제라는 것을 알고 있었다.문제를 읽어가며 최대 수익을 내기 위한 방법을 찾으려고 시도했지만 실패했다. 같은 일에 상담을 하더라도 Ti에 저장된 값이 다르면 수익을 얻는 날짜가 다르기 때문이다.아이디어가 도저히 떠오르지 않자 구글링을 통해 아이디어를 탐색했다.그 결과 뒤쪽 인덱스부터 접근해야 된다는 것과i일에 상담을 진행한 경우와 아닌 경우로 나눠 최댓값을 구하면 된다는 것을 알았다.i일에 상담을 진행할 때의 수익은 i+Ti일에서의 수익에 Pi를 더한 값이며,i일에 상담을 진행하지 않았을 때의 수익은 i+1일에서의 최댓값이다.즉 i일에서의 최댓값은 상담을 진행할 때, 진행하지 않았을 때 중 더 최댓값을 선택하면 된다.💡 문제 풀이위에서의 아이디어를 정리하면 다음과 같다.✅ i일에서의 최대 수익은 다음 중 큰 값에 해당 i일에 상담⭕: P[i]+dp[i+Ti] i일에 상담❌: dp[i+1]이를 파이썬 코드로 나타내면 다음과 같다.if i+T[i]&gt;N+1: dp[i] = dp[i+1]else: dp[i] = max(dp[i+1], P[i]+dp[i+T[i]])이때 주의해야 할 부분은 N일 이후에는 수익을 낼 수 없으므로 이에 대한 예외처리를 해야한다는 것이다.또 이 부분에 어떤 식을 넣어줄 것인가도 고민해야 한다. 필자는 처음에 continue를 썼다가 해당하는 dp[i]에 모두 0이 저장되는 바람에 else에서 이전 값들이 갱신되지 않는 문제가 발생했다.📂 코드위 문제 풀이 방식을 통해 해당 문제를 풀어낸 필자의 코드는 다음과 같다.import sysread = sys.stdin.readlineN = int(read().strip())T, P = [0], [0]for i in range(1, N+1): t, p = map(int, read().split()) T.append(t) P.append(p)dp = [0]*(N+6) # i번째 일에 상담 시 얻을 수 있는 최대 수익for i in range(N, 0, -1): if i+T[i]&gt;N+1: dp[i] = dp[i+1] else: dp[i] = max(dp[i+1], P[i]+dp[i+T[i]])print(dp[1])" }, { "title": "[HTML] HTML 태그의 종류", "url": "/posts/html-tag/", "categories": "HTML", "tags": "HTML, tag, 태그", "date": "2022-12-13 00:00:00 +0900", "snippet": "📂 HTML 태그📌 h 태그문서에 대한 정보를 나타내는 태그문서 내의 h1은 하나만!&lt;h1&gt;hello world&lt;/h1&gt;&lt;h2&gt;hello world&lt;/h2&gt;&lt;h3&gt;hello world&lt;/h3&gt;&lt;h4&gt;hello world&lt;/h4&gt;&lt;h5&gt;hello world&lt;/h5&gt;&lt;h6&gt;hello world&lt;/h6&gt;&lt;!-- h${hello world}*6와 동일 --&gt;📌 p 태그문단을 나타내는 태그&lt;p&gt;hello world&lt;/p&gt;&lt;p&gt;H&lt;sub&gt;2&lt;/sub&gt;0&lt;/p&gt;&lt;p&gt;x&lt;sup&gt;2&lt;/sup&gt;=4&lt;/p&gt;📌 br 태그개행을 위한 태그(enter가 아닌 br 태그를 이용해야 함.)📌 hr 태그구분선을 나타내는 태그📌 a 태그어디론가 이동하게 해주는 태그&lt;a href=\"https://day0522.github.io/\"&gt;click&lt;/a&gt; &lt;!-- url로 이동 --&gt;&lt;a href=\"https://day0522.github.io/\" target=\"_blank\"&gt;click&lt;/a&gt; &lt;!-- 새 창에서 url로 이동 --&gt;&lt;a href=\"./index.html\"&gt;click&lt;/a&gt; &lt;!-- 현재 폴더의 파일로 이동 --&gt;&lt;a href=\"#move\"&gt;click&lt;/a&gt; &lt;!-- move라는 id를 가진 태그로 이동 --&gt;&lt;a href=\"./test.png\" download&gt;click&lt;/a&gt; &lt;!-- 해당 파일 다운로드드 --&gt;📌 link 태그해당 문서와 외부 소스(external resource) 사이의 관계를 정의할 때 사용&lt;head&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/examples/media/expand_style.css\"&gt;&lt;/head&gt;📌 strong/b 태그굵은 폰트로 적용해주는 태그이때 strong 태그는 음성 인식 시 강조해서 읽는다. (시각 장애인을 위함)📌 em/i 태그기울어진 폰트로 적용해주는 태그이때 em 태그는 음성 인식 시 강조해서 읽는다. (시각 장애인을 위함)📌 mark 태그폰트를 강조해주는 태그(이떄 강조의 색은 CSS로 변경 가능)📌 그외 태그 abbr : 준말 표현(NASA) kbd : 키보드 pre : 있는 그대로 code : 코드블록 cite : 인용(q는 인용구, cite는 인용블록)📌 주석 작성Ctrl + / 를 통해 쉽게 작성할 수 있다." }, { "title": "[백준] 11729 하노이 탑 이동 순서(Python)", "url": "/posts/BOJ-11729/", "categories": "백준", "tags": "백준, algorithm, 알고리즘, 재귀, recursion, 하노이 탑", "date": "2022-11-27 00:00:00 +0900", "snippet": "해당 게시글에서는 [백준] 11729 하노이 탑 이동 순서 문제를 해설하고 Python을 이용하여 풀고자 한다.💡 문제 풀이11729번 문제는 재귀(recursion)로 유명한 하노이 탑 문제에 해당한다.해당 문제에서는 입력된 초기 원판의 개수에 대해 하노이 탑 규칙에 따라 모든 원판을 이동시킬 때 옮긴 횟수(K)와 이동 경로를 출력해야 한다.하노이 탑을 재귀적으로 구현하기 위해 원판 개수에 따라 반복되는 과정이 있는지 고민하는 시간을 가졌으며, 그 결과는 다음과 같다. N개의 원판을 모두 옮기기 위해, 먼저 N-1개의 원판(가장 큰 원판을 제외한 나머지)을 다른 장대로 옮긴다. 가장 큰 원판을 세 번째 장대로 옮긴다. 이전에 옮긴 N-1개의 원판을 세 번째 장대로 옮긴다.위의 내용을 통해 재귀적으로 코드를 작성하면 다음과 같다. 자세한 코드는 아래를 참고하길 바란다.hanoi(N-1, start, end, via) # N-1개의 원판 이동hanoi(1, start, via, end) # 가장 큰 원판 이동hanoi(N-1, via, start, end) # N-1개의 원판을 가장 큰 원판 위로 이동📂 코드 start: 시작하는 장대 via: 경유하는 장대 end: 최종으로 모든 원판이 도착하는 장대```pythonglobal movemove = []def hanoi(N, start, via, end): “”” :param N: 원판의 수 :param start: 시작 기둥 :param via: 중간 기둥 :param end: 끝 기둥 :return: 이동 횟수 “”” if N &lt;= 1: # 원판이 1개 있는 경우 move.append((start, end)) return 1cnt = 0cnt += hanoi(N-1, start, end, via) # N-1개의 원판을 보조 기둥에 모두 이동cnt += hanoi(1, start, via, end) # 가장 큰 원판을 끝 기둥에 이동cnt += hanoi(N-1, via, start, end) # N-1개의 원판을 끝 기둥에 이동return cntprint(hanoi(int(input()), 1, 2, 3))for f, t in move: print(f, t)```" }, { "title": "[백준] 2447 별 찍기 - 10(Python)", "url": "/posts/BOJ-2447/", "categories": "백준", "tags": "백준, algorithm, 알고리즘, 재귀, recursion, 별 찍기", "date": "2022-11-23 00:00:00 +0900", "snippet": "해당 게시글에서는 [백준] 2447 별 찍기 - 10 문제를 해설하고 Python을 이용하여 풀고자 한다.💡 문제 풀이2447번 문제는 별 찍기 문제이다.처음에 문제를 읽었을 때 단번에 이해가 되지 않았다. 지문과 예제를 동시에 보며 조금 고민하고 나서야 문제가 이해됐다.단계별로 풀어보기 카테고리를 통해서 들어왔기 때문에 해당 문제가 재귀(recursion)와 관련된 문제인 걸 알고 있었다. 그래서 재귀적으로 해당 문제를 풀기 위해 근접한 입력값들에 대해 어떤 규칙이 있는지 생각해 봤으며, 그 결과 다음과 같은 결론을 내릴 수 있었다. N을 출력하기 위해선 N//3의 출력 결과가 필요하다. N을 출력할 때는 N/3의 출력을 3번씩 3줄에 걸쳐 출력하면 된다. 이때 2줄의 2번째 출력은 공백이어야 한다.위 사실을 알면 해당 문제를 어렵지 않게 풀 수 있다. (규칙은 어느 정도 잘 알아냈지만, 각 출력을 어떤 형태로 저장할지에 대한 고민이 조금 많긴 했다…)📂 Code 1️⃣재귀 함수를 작성할 때 중요한 점은 예외 처리를 해야 한다는 것이다.여기선 n이 1일 때가 최초 입력이며 그때의 결과는 ‘*‘이므로 해당 문자를 반환하게 했다.입력 n에 대해 별을 찍기 위해서는 n//3의 출력이 필요하므로 재귀 함수를 이용해 반환값을 저장하도록 했다.입력이 n일 때 출력은 n줄 출력되므로 for문을 n번 돌며 위에 작성한 규칙에 따라 배열(result)에 문자열을 저장해 주었다.def draw_star(n): # 배열(ans)에 ***를 저장 if n == 1: return '*' star = draw_star(n//3) result = [] for i in range(n): if (i // (n//3)) == 1: result.append(star[i%(n//3)] + ' ' * (n//3) + star[i%(n//3)]) continue result.append(star[i%(n//3)] * 3) return resultans = draw_star(int(input()))for a in ans: print(a)📂 Code 2️⃣위와 같이 코드를 작성하면서, 규칙에 따라 수식들을 작성하는 게 머리가 아팠다. 더 쉬운 방법이 있을 거 같아 구글링 해 본 결과 다음과 같이 더욱 간단하게 풀어냈다.Code 1️⃣에서는 for문 하나에 걸쳐 모든 값을 저장하려고 했는데 그럴 필요가 없었다는 걸 깨달았다. 그렇게 풀이하려고 하니까 예외 처리 및 인덱스 접근을 하기 위해 수식 처리하는 것이 어려워졌다고 생각한다.아래와 같이 이전 입력(n //3)에 대한 for문을 각각 3번 돌리면 출력이 더def draw_star(n): if n == 1: return '*' stars = draw_star(n//3) # 이전 단계의 별의 패턴을 저장(재귀) result = [] for s in stars: result.append(s * 3) for s in stars: result.append(s + ' ' * (n//3) + s) for s in stars: result.append(s * 3) return resultans = draw_star(int(input()))for a in ans: print(a)" }, { "title": "[백준] 1431 시리얼 번호(Python)", "url": "/posts/BOJ-1431/", "categories": "백준", "tags": "백준, algorithm, 알고리즘, 정렬, 시리얼 번호", "date": "2022-09-09 00:00:00 +0900", "snippet": "해당 게시글에서는 [백준] 1431 시리얼 번호 문제를 해설하고 Python을 이용하여 풀고자 한다.🤔 접근법1341번 문제는 정렬에 관한 문제이다.애초에 문제에서 정렬이라고 밝히고 있기 때문에 정렬 문제라는 걸 아는 건 크게 어렵지 않을 것이다.시리얼번호 A가 시리얼번호 B의 앞에 오는 조건은 다음과 같이 해석할 수 있다. A와 B의 길이가 다르면, 짧은 것이 먼저 온다. 👉 문자열의 길이에 따라 정렬 만약 서로 길이가 같다면, A의 모든 자리수의 합과 B의 모든 자리수의 합을 비교해서 작은 합을 가지는 것이 먼저온다. (숫자인 것만 더한다) 👉 각 자리 숫자의 모든 합에 따라 정렬 만약 1,2번 둘 조건으로도 비교할 수 없으면, 사전순으로 비교한다. 숫자가 알파벳보다 사전순으로 작다. 👉 사전순 정렬(기본 sort 정렬)따라서 람다함수를 통해 정렬의 우선 순위에 따라 인자를 잘 넘겨주면 될 것이라 생각했다.하지만 첫 번째, 세 번째 조건은 len() 함수와 일반적인 sort를 쓰면 될 것이라 생각했지만, 두 번째 조건을 처리할 방법을 모르겠어서 다른 블로그를 참고했다.💡 문제 풀이이제 문제의 조건은 모두 파악했으므로 sort 함수와, 정렬의 조건이 되는 lambda 식을 잘 작성하면 된다.첫 번째 조건은 len 함수를, 세 번째 조건은 원래 값을 lambda에 넘겨주면 되지만, 두 번째 조건을 바로 나타낼 수 있는 함수는 없다.따라서 다음과 같이 string에서의 숫자 문자들의 합을 반환하는 함수를 정의했다.def sum_digit(str): ans = 0 for s in str: if s.isdigit(): ans += int(s) return ans모든 조건을 처리할 수 있게 됐으므로 이제 lambda 식을 작성하면 된다.lambda를 통해 여러 조건에 따른 정렬을 할 때, 조건이 앞에 올수록 먼저 정렬된다는 것을 알아두자. 또 lambda에 넘겨준 매개변수의 값이 작을수록 앞에 위치한다.우선순위가 큰 것이 앞에 와야하므로 첫 번째 조건인 string의 길이를 나타내는 len(x)를 맨 앞에, 두 번째 조건인 sum_digit(x)를 그 다음에, 사전순 정렬(일반 정렬)을 나타내는 x를 마지막에 작성했다.sorted(num, key=lambda x:(len(x), sum_digit(x), x))📂 Code위 문제 풀이 방식을 통해 해당 문제를 풀어낸 필자의 코드는 다음과 같다.import sysread = sys.stdin.readlinedef sum_digit(str): ans = 0 for s in str: if s.isdigit(): ans += int(s) return ansnum = [read().strip() for _ in range(int(read().strip()))]for n in sorted(num, key=lambda x:(len(x), sum_digit(x), x)): print(n)" }, { "title": "[JAVA] 클래스명과 파일명은 왜 같아야 하는가?", "url": "/posts/JAVA-classname/", "categories": "JAVA", "tags": "JAVA, 자바, HelloWorld, 출력, print", "date": "2022-08-03 00:00:00 +0900", "snippet": "해당 게시글은 JAVA로 Hello World 출력하는 방법을 학습하던 중 .java 파일의 이름과 내부 클래스명이 같아야 한다는 사실에 궁금증이 생겨 작성한 글이다.💡 JAVA 클래스명과 파일명은 왜 같아야 하는가?이는 다음과 같은 이유가 있다고 한다. Java 프로그램을 작성할 때는 .java 파일로 저장되지만 컴파일 될 때는 .class 파일인 바이트 코드를 형성한다. 따라서 클래스 이름을 파일명과 동일하게 만들면 모호함이 사라진다는 것이다. JVM이 해당 클래스를 진입점으로 인식해야 하기 때문이다. 이때 JVM은 Java Virtual Machine의 줄임말로 OS에 종속받지 않고 CPU가 JAVA를 인식/실행할 수 있게 하는 가상 컴퓨터이다. 만약 이름이 다르다면, 소스 파일에 class가 하나 이상인 경우 JAVA 인터프리터가 해석해야 하는 class와 프로그램의 진입점을 포함하는 class를 쉽게 인식할 수 없다. 하지만 클래스가 public이 아닌 경우엔 동일하지 않아도 된다고 한다." }, { "title": "[JAVA] Hello World!!", "url": "/posts/JAVA-HelloWorld/", "categories": "JAVA", "tags": "JAVA, 자바, HelloWorld, 출력, print", "date": "2022-08-02 00:00:00 +0900", "snippet": "해당 게시글은 생활코딩 JAVA1 강의를 기반으로 하며, 이에 필자의 생각을 추가해 작성한 글이다.참고로 필자는 지금까지 Cpp, Python을 위주로 공부해온 사람이다.🔍 Hello World 출력하기모든 언어의 기초가 되는 Hello World 출력을 JAVA로 해보려고 한다!JAVA에서는 아래 코드와 같이 Hello World를 출력할 수 있다.(참고로 sout을 치고 Tab을 누르면 출력 코드를 편하게 작성할 수 있다.)C++에서 main 함수를 쓰는 것과 같이 정형화 된 문법인 거 같다.JAVA : HelloWorldApp.javapublic class HelloWorldApp{ public static void main(String[] args){ System.out.println(\"Hello World!!\"); }}위 코드에서 유의해야 할 점은 다음과 같다. 첫 줄의 클래스 이름 main 함수1️⃣ 첫 줄의 클래스 이름첫 줄의 클래스 이름을 보면 HelloWorldApp인 것을 볼 수 있다. 이는 필자가 저장한 현재 파일의 이름인 HelloWorldApp.java와 동일하다.JAVA에서는 클래스명과 파일명이 동일해야 한다고 한다.하지만 궁금해졌다… 도대체 왜?현재 게시글에 모두 작성하면 내용이 길어지기 때문에 호기심이 생긴다면 JAVA 클래스명과 파일명은 왜 같아야 하는가?를 읽어보길 바란다.2️⃣ main 작성 코드JAVA의 main 코드에서 public static void main(String[] args)는 정형화된 듯하다.이때 public이 쓰이는 이유는 main은 프로그램의 모든 method의 기본이 되기 때문에 모든 곳에서 접근할 수 있어야 하기 때문이다.또 생긴 궁금증이 괄호 안에 argument가 꼭 있어야 한다는 점이다. 만약에 지우게 되면 error가 발생한다. 그 이유는 main은 프로그램이 시작되는 부분이므로 어떠한 데이터를 넘겨줘야 하는 경우도 있기 때문이다. 즉, 외부에서 값을 받을 수 있게 하기 위함이다.JAVA에 대한 첫 글이다 보니 의지가 불타올라 이런저런 궁금증을 해결하며 학습하려고 했다. 이 의지가 계속 이어가면 굉장히 좋겠다…🙄" }, { "title": "[백준] 10844 쉬운 계단 수(Python)", "url": "/posts/BOJ-10844/", "categories": "백준", "tags": "백준, algorithm, DP, 다이나믹 프로그래밍, 쉬운 계단 수, BOJ", "date": "2022-07-15 00:00:00 +0900", "snippet": "해당 게시글에서는 [백준] 10844 쉬운 계단 수 문제를 해설하고 Python을 이용하여 풀고자 한다.🤔 접근법문제 풀이 방식을 빠르게 알고싶다면 💡문제 풀이 부분 부터 봐주세요 :)10844 문제는 DP(다이나믹 프로그래밍)에 대한 문제로 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법하는 방식의 알고리즘이다.문제 접근 방식은 유사한 DP 문제를 많이 풀어봐서 그다지 어렵지 않았다. 다른 때와 똑같이 규칙을 찾기위해 N에 따른 값들을 분석했다.N이 1인 경우와 2인 경우를 나열해보면 어렵지 않게 규칙을 찾을 수 있다. N이 1인 경우: 1, 2, 3, 4, 5, 6, 7, 8, 9 N이 2인 경우: 10, 12, 21, 23, 32, 34, 43, 45, 54, 56, 65, 67, 76, 78, 87, 89, 98위의 N이 2인 경우의 10과 12는, N이 1인 경우인 1에서 차이가 1이 나는 숫자들을 뒤에 이어붙인 것이다.21와 23, 32와 34도 동일하게 각각 2와 3에 차이가 1인 숫자를 연달아 붙인 것이다.즉 계단수를 만들기 위해서는 이전 계단수의 일의 자리 숫자에 +1, -1한 숫자를 맨 끝에 붙여주면 된다. 따라서 다음 N에서는 계단수가 2배가 되는 것을 알 수 있다.하지만 여기서 주의해야 할 점은 0과 9 같이 경계값에서는 계단수가 2개가 아닌 1개만 생성된다는 것이다.처음엔 이전 계단수를 2배한 뒤, 끝이 0과 9인 것의 개수를 빼주려고 했다. 하지만 끝이 0과 9인 것의 개수를 세주는 과정이 쉽지 않았다. (이 방법으로도 풀 수 있을 거 같은데… 혹시나 아신다면 알려주세요!)그래서 새로운 방법을 생각하다가 든 생각이 끝자리가 i인 계단수의 개수는 얼마지?였다. 끝자리가 i가 되기 위해서는 이전 길이에서의 끝자리가 i-1, i+1이면 된다.즉 길이가 N일 때 일의 자리가 i인 계단수의 개수는, 길이가 N-1일 때 일의 자리가 i-1, i+1인 계단수의 개수를 각각 합한 것이다. 해당 아이디어만 있다면 이제 구현은 어렵지 않다.💡 문제 풀이길이가 N인 계단수를 일의 자리 숫자에 따라 배열에 분리해보자. 예를 들면 N이 1일 때 계단수는 1~9가 있으므로 [0, 1, 1, 1, 1, 1, 1, 1, 1, 1]로 정하는 것이다. (계단수 중에서는 일의 자리가 0인 것도 있으므로 0에 대한 인덱스도 만들어 줘야 한다.)그렇다면 N이 2일 때 계단수의 배열은 어떻게 될까?위에서 길이가 N일 때 일의 자리가 i인 계단수의 개수는, 길이가 N-1일 때 일의 자리가 i-1, i+1인 계단수의 개수를 각각 합한 것이라고 했으므로, N이 2일 때 인덱스 i에서의 계단수는 arr[1][i-1]+arr[1][i+1]이 된다.모든 인덱스에 대해 계산해주면 N이 2일 때의 배열은 [1, 1, 2, 2, 2, 2, 2, 2, 2, 1]이 된다.이를 일반화 한 식은 다음과 같다. dp[N][i] = dp[N-1][i-1] + dp[N-1][i+1]아직 이해가 되지 않았다면, 위 식의 N과 i에 숫자를 대입하여 아래 표와 비교해보길 바란다. index 0 1 2 3 4 5 6 7 8 9 10 dp[1] 0 1 1 1 1 1 1 1 1 1 1 dp[2] 1 1 2 2 2 2 2 2 2 2 1 dp[3] 1 3 3 4 4 4 4 4 4 3 2 dp[4] 3 4 7 7 8 8 8 8 7 6 3 📂 코드이제 구현만 남았다. 하지만 위 식을 그대로 이용해 코드를 짠다면 에러가 발생할 것이다. 아직 0과 9일 때의 예외처리를 하지 않았기 때문이다.일의 자리가 0일 때는 오로지 1에서부터, 일의 자리가 9일 때는 오로지 8에서부터 계단수가 만들어진다. 따라서 dp[N][0] = dp[N-1][1], dp[N][9] = dp[N-1][8]이다.필자는 인덱스가 0과 9일 때를 for문 따로 빼주고 위 식처럼 대입했다.N번째 배열을 만들기 위해서는 N-1번째 배열만 있으면 된다. 위 식을 그대로 사용하면 N에 따라 모든 배열을 만들어 줘야 하므로 메모리 낭비가 심할 것이라고 생각했다.따라서 이전 값을 따로 저장해두고 dp 배열을 이전 배열에 따라 갱신하는 형태로 코드를 구현했다.N = int(input())dp = [0]+[1]*9for _ in range(N-1): prev = dp[:] # 이전 dp 복사 dp[0] = prev[1] for i in range(1, 9): dp[i] = prev[i-1]+prev[i+1] dp[9] = prev[8]print(sum(dp)%1000000000)" }, { "title": "[백준] 12847 꿀 아르바이트(Python)", "url": "/posts/BOJ-12847/", "categories": "백준", "tags": "백준, algorithm, 투 포인터, 두 포인터, 알고리즘, two pointer, sliding window, 꿀 아르바이트", "date": "2022-05-17 00:00:00 +0900", "snippet": "해당 게시글에서는 [백준] 12847 꿀 아르바이트 문제를 해설하고 Python을 이용하여 풀고자 한다.💡 문제 풀이1522번 문제는 투 포인터에 대한 문제 중에서도 슬라이딩 윈도우 알고리즘 문제에 해당한다.슬라이딩 윈도우 알고리즘이 된 이유는 다음의 조건 때문이다. 한 번이라도 퇴직한 자를 다시 취직 시키지 않는다.(만약 취직을 한다면, 일을 시작 한 날부터 끝날 때까지 하루도 빠지면 안 된다.)죽, 준수가 일을 할 수 있는 날(m)이 주어졌을 때 일을 시작한 날(st)로부터 m일 동안 빠짐없이 일해야 한다는 것이다. 따라서 준수가 최대 이익을 얻기 위해선 시작한 날(st)로부터 m일 동안 일했을 때의 이익을 모든 경우에 대해서 구하고 최댓값을 출력해주면 된다. m일이라는 길이가 계속 고정되기 때문에 슬라이딩 윈도우 문제가 되는 것이다.🔒 코드(시간 초과)위에서 설명한 풀이에 의해 다음과 같이 코드를 작성했다. 하지만 아래의 코드로 제출하면 시간 초과가 발생한다.n, m = map(int, input().split())money = list(map(int, input().split()))max_val = 0for st in range(n-(m-1)): max_val = max(max_val, sum(money[st:st+m]))print(max_val)알고리즘 분류를 확인해보면 슬라이딩 윈도우 뿐만 아니라 누적 합에 해당하는 것을 알 수 있는데, 누적 합을 이용하여 불필요한 연산을 줄일 수 있다.각 일수에 해당하는 합을 구하는 과정에서 참조하려는 인덱스가 (st)~(st+(m-1))일 때와 (st+1)~(st+m)일 때 (st+1)~(st+(m-1))에 해당하는 값은 공통된 값이다. 따라서 해당 범위에 있는 값들에 대해서는 새롭게 더해주지 않고 이전 값을 이용하면 덧셈에 대한 연산량을 줄일 수 있다.📂 코드위의 설명과 같이 누적 합의 개념을 추가적으로 적용하여 아래와 같이 문제를 해결했다.n, m = map(int, input().split())money = list(map(int, input().split()))sum = ans = sum(money[0:m])for st in range(n-m): sum -= money[st] sum += money[st+m] ans = max(ans, sum)print(ans)" }, { "title": "[백준] 1522 문자열 교환(Python)", "url": "/posts/BOJ-1522/", "categories": "백준", "tags": "백준, algorithm, 투 포인터, 두 포인터, 알고리즘, two pointer, sliding window, 문자열 교환", "date": "2022-05-16 00:00:00 +0900", "snippet": "해당 게시글에서는 [백준] 1522 문자열 교환 문제를 해설하고 Python을 이용하여 풀고자 한다.💡 문제 풀이1522번 문제는 투 포인터에 대한 문제로 두 개의 포인터를 조절하여 두 포인터가 가리키는 값이 특정한 조건을 만족하도록 하는 방식의 알고리즘이다. 투 포인터 알고리즘 중에서도 두 포인터를 일정한 간격으로 이동하는 슬라이딩 윈도우 알고리즘에 해당한다. 슬라이딩 윈도우인 이유는 아래 문제 해설에서 설명하겠다.이 문제에서 구하고자 하는 값은 a와 b로만 이루어진 문자열에 대해 a를 모두 연속으로 만들기 위한 최소 교환 횟수이다.예시를 통해 풀이 방법을 설명하기 전에 다음을 이해하자!1️⃣ 교환 후 연속된 a 문자열의 길이는 입력된 문자열 속 a의 개수와 같다.2️⃣ 즉, a의 개수와 동일한 길이로 연속된 문자열을 슬라이싱 하고 슬라이싱한 문자열 내부에 있는 b와 외부에 있는 a와 교환하면 a가 연속되게 된다. 이때 교환 횟수는 슬라이싱한 문자열 내부에 있는 b의 개수와 동일하다.🔎 예제만약 abababababababa가 입력으로 주어졌다고 하자. 포인터는 문자열의 0번째 인덱스에 위치한 a에서부터 시작한다. 입력된 문자열에서의 a의 개수는 8개이다. 즉 최종적으로 교환이 일어난 후의 a가 연속된 문자열의 길이는 8이라는 것이다. 그럼 0번째 인덱스부터 8개를 슬라이싱 하면 다음과 같이 된다.✔ (abababab)abababa() 안에 있는 값이 슬라이싱한 문자열이며, () 내부에 있는 부분을 모두 a로 연속되게 만들고 싶은 것이다. 그러기 위해선 () 내부의 b의 값을 () 외부의 a값과 교환하면 된다. 그렇다면 교환 횟수는 b의 개수가 되며 해당 예제에서는 4가 된다.✔ a(babababa)bababa인덱스를 한 칸 더 옮겨 봐보자. 아까 설명했던 것과 같이 () 안에 있는 b의 값을 외부의 a값과 교환해줘야 하므로 해당 예제에서의 교환 횟수는 4가 된다.이와 같이 입력된 문자열을 슬라이싱 할 수 있는 부분에 대해 모두 a의 개수와 동일한 길이로 슬라이싱 하여 모든 경우에 대해 교환 횟수(슬라이싱한 문자열 내부의 b의 개수)를 구한 후 최솟값을 구하면 된다. 이때 동일한 길이로 계속해서 슬라이싱 하기 때문에 슬라이딩 윈도우에 해당하는 문제인 것이다.다음은 for문을 이용해 시작 포인터(i) 위치 부터 동일한 길이(a의 개수)로 슬라이싱하여 b의 개수를 세고 모든 경우에 대해 값을 구하여 그 중 최소값을 구하는 코드다.for i in range(len(s)-(a-1)): min_val = min(min_val, s[i:i+a].count('b'))📌 주의사항문제의 조건에 원형 문자열이라는 조건이 있다. 이는 다음과 같이 슬라이싱이 가능하다는 것이다.✔ ababab)abababa(ba따라서 이를 처리 하기 위해 코드에서 문자열을 다음 코드와 같이 늘려주었다. 그냥 동일한 s를 더해줘도 되지만 필요 없는 부분까지 더해줄 필요가 없으므로 s[0:a-1]과 같은 문자열을 더해주었다.s += s[0:a-1] # 원형 문자열for문의 range가 len(s)-(a-1)까지 인 것도 원형 문자열을 처리하면서 기존에 입력된 문자열의 길이가 변형되어서 따로 처리를 해준 것이다.📂 코드s = input() # 문자열 입력a = s.count('a') # 입력된 str에서의 a의 개수s += s[0:a-1] # 원형 문자열 처리min_val = float('inf') # 최솟값for i in range(len(s)-(a-1)): min_val = min(min_val, s[i:i+a].count('b'))print(min_val)" }, { "title": "[백준] 13305 주유소(Python)", "url": "/posts/BOJ-13305/", "categories": "백준", "tags": "백준, algorithm, greedy, 알고리즘, 그리디, 주유소", "date": "2022-05-15 00:00:00 +0900", "snippet": "해당 게시글에서는 [백준] 13305 주유소 문제를 해설하고 Python을 이용하여 풀고자 한다.💡 문제 풀이13305번 문제는 Greedy에 대한 문제로 각 단계마다 최적의 상황을 선택하여 최종적인 해답에 도달하는 방식의 알고리즘이다.이 문제에서는 제일 오른쪽 지점에 도달했을 때 기름의 비용이 최소가 되는 것을 원하므로, 각 도시를 지나기 위해 기름의 비용을 계산할 때 상황에 따라 작은 값을 이용하여 계산해야 한다.만약 앞 도시의 기름의 비용이 뒷 도시의 기름의 비용보다 싸다면, 앞 도시에서 주유하는 것이 비용이 적게 드므로 뒷 도시에서 주유하는 것이 아닌 앞 도시에서 미리 주유해야 한다.따라서 왼쪽에서 오른쪽으로 순차적으로 이동하면서 최소 비용을 저장하여 (최소 비용)*(각 도시 사이 거리)를 더해줘야 한다.아래 코드는 각 도시를 이동할 때 최소 비용인지 확인하고 최소 비용이라면, 이후에 주유 비용을 계산할 때 사용하기 위해 최소값을 저장하는 부분이다.if cost[i] &lt; cost[cur]: cur = i위에서 계산한 최소 비용을 통해 각 도시를 지나칠 때마다 (최소 비용)*(도시 사이 거리)를 최종 비용을 저장하는 변수에 더한다.result += cost[cur]*len[i]📂 코드 cur: 최소 비용이 되는 도시의 index를 저장N = int(input()) # 도시의 개수len = list(map(int, input().split())) # 각 도시 사이 거리cost = list(map(int, input().split())) # 주유 비용cur = 0 # 최적(최소)의 비용 저장result = 0 # 주유 비용 합계for i in range(0, N-1): if cost[i] &lt; cost[cur]: cur = i result += cost[cur]*len[i]print(result)" }, { "title": "[Algorithm] BFS(Breadth-First Search)", "url": "/posts/BFS-algorithm/", "categories": "Algorithm", "tags": "Algorithm, BFS, 알고리즘, 그래프, 너비우선탐색", "date": "2022-05-14 00:00:00 +0900", "snippet": "1. BFS란? BFS란 루트 노드(Node)에서 시작하여 인접한 노드를 방문할 때 너비를 우선으로 방문하는 알고리즘이다. 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다. 이때 한 번 방문한 정점은 다시 방문하지 않는다. 노드 사이의 최단 경로를 구하고자 할 때, 혹은 임의의 경로를 찾고자 할 때 BFS를 이용한다.2. BFS를 코드로 구현하려면?1️⃣ 시작하는 정점을 큐에 삽입하여 방문했다는 표시를 남긴다.2️⃣ 큐의 제일 앞에 있는 원소를 삭제한 후, 해당 원소에 연결돼 있으면서 아직 방문하지 않은 정점을 큐에 삽입한다.3️⃣ 큐가 비어있을 때까지 2️⃣를 반복한다.이때 모든 정점(Node)을 한 번, 모든 간선(Edge)을 두 번씩 방문하므로 시간복잡도는 정점이 N개일 때 O(N+E)이다.해당 과정을 거치면 그래프에 연결된 모든 정점을 단계별로 방문할 수 있다.📂 기본 예제 코드(Python) graph는 각 인덱스 원소에 대한 인접 원소 visited는 각 원소의 방문 여부를 저장하는 리스트(방문 시 True, 미방문 시 False)# 큐 구현을 위한 deque 라이브러리 활용from collections import deque# BFS 함수 정의def bfs(graph, start, visited): queue = deque([start]) # 시작 노드를 방문 처리 visited[start] = True # 큐가 완전히 빌 때까지 반복 while queue: # 큐에서 원소 하나를 pop v = queue.popleft() print(v, end=' ') # pop한 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입 for i in graph[v]: if not visited[i]: queue.append(i) visited[i] = True# 각 노드가 연결된 정보를 2차원 리스트로 표현graph=[ [], # 0번 노드 비우기 [2, 3, 8], # 1번 노드와 연결된 2, 3, 8 노드 [1, 7], [1, 4, 5], [3, 5], [3, 4], [7], [2, 6, 8], [1, 7]]# 방문 정보 저장할 리스트visited = [False]*(8+1) # (총 노드의 개수 + 인덱스 0 저장) 크기로 선언# bfs 실행bfs(graph, 1, visited)💡 미로 예제에 적용다음 코드는 미로 예제에 대해 BFS를 적용한 코드이다.# BFS를 미로 문제에 적용from collections import deque# n개의 행, m개의 열n, m = map(int, input().split())# 미로의 정보 입력maze = []for i in range(n): maze.append(list(map(int, input())))# 방향 정보(상하좌우)dx = [-1, 1, 0, 0]dy = [0, 0, -1, 1]# BFS maze 구현def bfs(x, y): # x, y는 시작점 queue = deque() queue.append((x, y)) # 큐에 시작점 삽입 # 큐가 빌 때까지 반복 while queue: x, y = queue.popleft() # 현재 위치에서 4가지 방향으로 위치 확인 for i in range(4): nx = x + dx[i] # x: 열 ny = y + dy[i] # y: 행 # 미로 찾기 공간을 벗어난 경우 무시 if nx&lt;0 or nx&gt;=n or ny&lt;0 or ny&gt;=m: continue # 아직 방문하지 않은 노드에 대해서만 최단 거리 기록 if maze[nx][ny] == 1: queue.append((nx, ny)) maze[nx][ny] = maze[x][y]+1 # 맨 끝까지의 최단 거리 반환 print(maze[n-1][m-1])# BFS 수행 결과 출력print(bfs(0, 0))BFS 이미지 출처: wikipedia" }, { "title": "[자료구조] 그래프(Graph)란?", "url": "/posts/graph/", "categories": "자료구조", "tags": "자료구조, graph, node, edge, 그래프, 간선, 정점", "date": "2022-05-13 00:00:00 +0900", "snippet": "1. 그래프(Graph)란?그래프란 실제 세계의 현상이나 사물의 정점(Vertex) 또는 노드(Node)와 간선(Edge)로 표현하기 위해 사용한다.위 이미지에서 A, B, C, D, E는 정점에 해당하며 각 정점들을 잇는 선은 간선에 해당한다.2. 그래프 관련 용어📌 주요 용어 노드(Node): 위치를 말하며, 정점(Vertex)라고도 함 간선(Edge): 위치 간의 관계를 표시한 선으로 노드를 연결한 선임(Link 또는 branch라고도 함) 인점 정점(Adjacent Vertex): 간선으로 직접 연결된 정점(또는 노드)📌 참고 용어 정점의 차수 (Degree): 무방향 그래프에서 하나의 정점에 인접한 정점의 수 진입 차수 (In-Degree): 방향 그래프에서 외부에서 오는 간선의 수 진출 차수 (Out-Degree): 방향 그래프에서 외부로 향하는 간선의 수 경로 길이 (Path Length): 경로를 구성하기 위해 사용된 간선의 수 단순 경로 (Simple Path): 처음 정점과 끝 정점을 제외하고 중복된 정점이 없는 경로 단, 시작 노드와 끝 노드는 동일해도 됨 사이클 (Cycle): 단순 경로의 시작 정점과 종료 정점이 동일한 경우3. 그래프 종류📌 무방향 그래프(Undirected Graph) 간선에 향이 없는 그래프 간선을 통해 노드는 양방향으로 갈 수 있음 A와 B 노드가 연결돼있을 때 (A, B)와 같이 표기(혹은 (B, A))📌 방향 그래프(directed Graph) 간선에 방향이 있는 그래프 간선을 통해 화살표 방향으로만 갈 수 있음 A와 B 노드가 A → B로 가는 간선으로 연결돼 있는 경우 &lt;A, B&gt;와 같이 표기(&lt;B, A&gt;는 B → A로 가는 간선을 의미)📌 가중치 그래프(Weighted Graph) 간선에 비용 또는 가중치가 할당된 그래프📌 연결 그래프(Connected Graph) 무방향 그래프에 있는 모든 노드에 대해 항상 경로가 존재하는 경우📌 비연결 그래프(Disconnected Graph) 무방향 그래프에서 특정 노드에 대해 경로가 존재하지 않는 경우📌 사이클(Cycle)와 비순환 그래프(Acyclic Graph) 사이클(Cycle): 단순 경로의 시작 노드와 종료 노드가 동일한 경우 비순환 그래프: 사이클이 없는 그래프📌 완전 그래프(Complete Graph) 그래프의 모든 노드가 서로 연결되어 있는 그래프해당 게시글은 패트스캠퍼스의 알고리즘 / 기술면접 완전 정복 올인원 패키지 Online 강의를 참고하여 작성하였습니다." }, { "title": "[Web] Status code", "url": "/posts/Status-code/", "categories": "Web", "tags": "Web, http, https, responce, Status Code", "date": "2022-05-03 00:00:00 +0900", "snippet": "HTTP Response의 첫번째 줄은 Version과 Status code로 구성돼있다. 이 글에서는 Status code 중 주로 사용되는 code에 대해 알아보고자 한다.1. Status codeStatus code란 사용자의 요청에 대한 서버의 처리 결과를 나타낸다.2. 주요 Status code📌 200번 영역사용자의 요청에 대한 서버의 처리가 성공하였음을 나타낸다. 200 OK 201 Created📌 300번 영역사용자가 요청한 리소스가 다른 경로로 변경된 경우를 나타내는 영역이다.웹 브라우저에서 300번 영역의 응답 상태 코드가 반환되면, Response Header에 포함되어 있는 Location 헤더의 값으로 리다이렉션 한다. 301 Moved Permanently 302 Found📌 400번 영역사용자가 서버에 요청하는 구조 또는 데이터가 잘못되었음을 나타내는 영역이다. 400 Bad Request 사용자가 전달한 데이터 또는 구조의 잘못된 문법으로 인해 서버가 요청을 이해할 수 없음\\ 403 Forbidden 사용자가 해당 웹 리소스에 접근할 권리를 가지고 있지 않음 404 Not Found 사용자가 요청한 웹 리소스의 경로에 응답할 데이터가 없음 405 Method Not Allowed 사용자가 요청한 Method가 서버에서는 하용하지 않는 Method임 📌 500번 영역서버의 에러와 관련된 영역 500 Internal Server Error 서버의 에러가 발생했음을 나타냄 503 Service Unavailable 서버의 사용자가 요청을 처리할 준비가 되지 않았음 " }, { "title": "[Web] 웹이란 무엇인가?", "url": "/posts/Introduction-of-Web/", "categories": "Web", "tags": "Web, http, https, resource, URL, URI, encoding, URI 구성 요소", "date": "2022-05-02 00:00:00 +0900", "snippet": "학과 복지를 위한 웹 사이트 프로젝트에 지원하기 위해 백엔드에 대한 공부가 필요했다. 이를 위해 백엔드 스터디를 신청했으며, 본격적으로 백엔드 공부를 하기에 앞서 웹에 대해 공부하고자 한다.1. 웹이란 무엇인가?웹(Web)을 공부하기 위해 기본적인 용어에 대해 알아보자. 웹(Web) : 인터넷상의 서비스 중 HTTP를 이용하여 정보를 공유하는 통신 서비스 웹 서버(Web Server) 사용자가 어떻게 호스트 파일들에 접근하는지를 관리 주소 HTTP 프로토콜을 사용하여 클라이언트의 요청을 처리 및 응답 웹 클라이언트(Web Client) : 서비스를 받는 사용자2. 데이터를 주고받는 과정의 원리 및 기술사용자(웹 브라우저)와 웹 서버가 데이터를 주고받는 과정의 원리와 기술을 단계별로 알아보자.📌 Web Browser(웹 브라우저) Chrome, Edge, Safari 등이 대표적인 웹 브라우저다.웹 브라우저란 웹에 접속하기 위해 사용하는 소프트웨어다. 웹 브라우저는 HTTP를 통해 인터넷 상에서 통신을 하며 서버로부터 전달받은 다영한 웹 리소스들을 가공해 사용자가 웹을 사용할 수 있도록 도와주는 소프트웨어다. 따라서 사용자는 HTTP의 원리와 동작 방식을 몰라도 웹 브라우저를 통해 웹의 불편함 없이 이용할 수 있다.📌 Web Resource웹 리소스는 웹에서 사용하는 콘텐츠를 의미한다.웹 브라우저의 주소창에 http://day0522.github.io/index.html 를 입력하면 day0522.github.io에 존재하는 /index.html 리소스에 대해 요청을 수행하는 것이다.웹 페이지를 구성하는 대표적인 웹 리로스들은 다음과 같다. HTML 웹 문서의 뼈대를 구축하기 위한 마크업 언어 정해진 태그와 속성을 지정하여 문서를 구성 CSS HTML이 표시되는 방법을 정의하는 스타일 시트 언어 이미지, 태그, 글자 등 다양한 웹 리소스의 출력에 대한 스타일 설정 HTML과 CSS는 화면에 뼈대를 그리는 것임 JS(JavaScript) 페이지 내에서의 행위들을 설정할 수 있음 Etc : 문서, 이미지, 동영상, 폰트 등📌 URI(URL) 쉽게 말하자면 URI는 주소창에 출력되는 주소 전체이다. URI : Uniform Resource Identifier의 약자로 리소스를 식별하기 위한 식별자 URL : Uniform Resource Locator의 약자로 리소스의 위치를 식별하기 위한 URI의 하위 개념웹 사이트의 주소를 이용해 접근한 것은 URL이자 URI를 이용한 것이다.📌 URI 구성 요소 Scheme : 웹 서버에 접속할 때 어떤 체계(프로토콜)를 이용할지에 대한 정보를 담고 있다. Authority : Host와 Port로 구성 Host(Domain) : 접속할 웹 서버의 호스트(서버 주소)에 대한 정보를 가지고 있음 Port 접속할 웹 서버의 포트에 대한 정보를 가지고 있음 포트가 명시되어 있지 않으면 각 프로토콜에 해당하는 표준 포트(HTTP:80, HTTPS:443)로 해석함 Path : 접속할 웹 서버의 경로에 대한 정보를 가지고 있으며 / 문자로 구분됨 Query : 웹 서버에 전달하는 파라미터(추가적인 정보)로 ? 문자 뒤에 붙음 Fragment 메인 리소스 내에 존재하는 서브 리소스에 접근할 때 이를 식별하기 위한 정보를 담고 있으며 # 문자 뒤에 붙음 해당 페이지 내 북마크 역할 어떤 링크를 눌렀을 때 페이지 내의 특정 위치로 이동시킴(서버로 전송시켜주는 데이터는 아님) 📌 EncodingEncoding(인코딩)은 문자 또는 기호 등의 정보, 형태를 표준화, 보안 등의 목적으로 다른 형태나 형식으로 변환하는 처리를 말한다. 이렇게 변환된 형태를 원래 형태로 변경하는 것을 Decoding(디코딩)이라 한다. Encoding(인코딩) : 알고리즘이 모두 공개되어 있으며 키와 같은 요소가 포함되어 있지 않아서 모두가 원래의 정보로 복원이 가능함 Encryption(인크립션) 양방향 암호 알고리즘 일치한 알고리즘과 유효한 키를 가지고 있다면 원래의 정보로 복원이 가능 웹에서 사용하는 대표적인 인코딩으로 URL과 HTML Entity가 있다. URL Encoding(percent encoding) URI 구조내에서 예약어(구분자)로 사용되는 문자들을 전송하고자 할 때 사용 인코딩 방식 입력된 문자를 Ascii테이블에서 매칭되는 Hex 값 앞에 %문자를 붙이면 됨 ?는 %3F, #은 %23, &amp;는 %26으로 나타낼 수 있다. |문자|URL 인코딩||:-----:|:-------:||?|%3F||#|%23||&amp;|%26||=|%3D| HTML entity Encoding HTML 문서에서 사용하는 문자열이 HTML 태그로 인식하지 않도록 하기 위해 사용 인코딩 방식 입력된 문자를 Ascii테이블에서 매칭되는 Hex 값 앞에 &amp;#x를 붙이면 됨 주요한 문자들에 대해서는 지정되어 있는 Entity name을 사용하면 됨 문자 Entity name encoding Entity number encoding &amp; %amp; &amp;#x26; &lt; %lt; &amp;#x3C; &gt; %gt; &amp;#x3E; 📌 HTTP https://day0522.github.io/ URI는 HTTPS 방식으로 day0522.github.io 서버와 통신하는 것이다.HTTP 또는 HTTPS는 URI의 구성 요소 중 Scheme(Protocol)에 해당한다. HTTP와 HTTPS의 핵심 구조 및 동작 원리는 동일하므로 HTTP로 통칭되기도 한다. Protocol(프로토콜) 컴퓨터 내부 혹은 컴퓨터 사이에서 어떻게 데이터를 교환할지를 정의하는 규칙 체계 HyperText Transfer Protocol(HTTP), HyperText Transfer Protocol Secure Socket Layer(HTTPS)은 웹에서 이루어지는 통신을 정의한 프로토콜이다. TCP 혹은 TLS(암호화된 TCP)를 사용해 통신하고 기본 포트로 80(HTTP), 443(HTTPS) 포트를 사용한다. 이때 포트 번호는 서버의 설정을 통해 변경 가능하다. HTTP는 사용자가 서버에 요청을 하는 Request와 사용자의 요청에 대한 서버의 응답인 Response로 나누어진다.📌 HTTP RequestHTTP Request는 서버에 대한 요청을 의미한다.HTTP Request의 구조 중 가장 첫번째 줄에는 Method, Path, Version으로 구성된다. 두 번째 줄부터는 Header 부분이며, 마지막에는 Body로 구성된다.GET /index.html HTTP/1.1Host: day0522.github.ioConnection: keep-aliveUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36HTTP Request 구성요소 Method: 서버에 요청 시 수행하고자 하는 동작을 나타냄 서버에서 설정하는 방식, 웹 어플리케이션의 처리에 따라 수행하는 방식이 다를 수 있음 OPTIONS: 요청하는 리소스가 허용되는 메소드 목록을 반환 GET: 리소스를 요청 ex) 게시물/프로필 보기, 이미지 등* HEAD: GET 메소드와 동일하지만, Response의 Body 부분은 받지 않고, Header만 받음 ex) 서버의 상태 확인 등 POST: 특정 리소스 생성 및 데이터 추가를 위해 값을 제출할 때 사용 ex) 게시물/프로필 생성 등 PUT: 특정 리소스의 내용을 보낸 값으로 설정 ex) 생성/업데이트 등 PATCH: 특정 리소스의 내용 중 보낸 값의 key만 변경 ex) 게시글 업데이트 등 DELETE: 특정 리소스를 삭제 ex) 게시물 삭제 등 TRACE: 요청받은 값을 Response의 Body로 다시 클라이언트에게 되돌려줌 Path: 사용자가 서버에 요청하는 웹 리소스의 경로 Version: HTTP의 버전 Header 이름: 값 형태로 이루어짐 서버에 추가 정보를 전달하는 데이터 부분 사용자와 서버가 상호작용하기 위한 정보를 담는 부분ex) 사용자 데이터의 처리 방식 및 형식에 대한 정보, 서버에서 사용자를 식별하기 위한 쿠기 정보 등 주요 Header Host: 데이터를 보내는 서버의 주소 Cookie: 사용자를 식별하기 위해 사용하는 정보 User-Agent: 사용자가 사용하는 프로그램의 정보 Referer: 페이지 이동 시 이전 URI의 정보 Content-Type 사용자가 전달하는 데이터의 처리 방식과 형식 사용자와 서버 간의 데이터 처리 방식이 일치돼야 정상적인 데이터 통신이 이루어짐 Body: 사용자가 입력한 데이터를 서버에 전달할 때 데이터를 담는 부분 📌 HTTP ResponseHTTP Response는 사용자의 요청에 대한 서버의 응답을 의미한다.HTTP Request의 구조 중 가장 첫번째 줄에는 Version, Status code로 구성된다. 두 번째 줄부터는 Header 부분이며, 마지막에는 Body로 구성된다.HTTP/1.1 200 OKServer: Apache/2.4.29 (Ubuntu)Content-Length: 61Connection: Keep-AliveContent-Type: text/html&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;HTTP Response 구성요소 Version: HTTP의 버전 Status Code: 사용자의 요청에 대한 서버의 처리 결과 주요 Status Code에 대해 자세히 알고 싶다면 여기 게시글을 확인하자. Header: 사용자와 상호작용하기 위한 데이터를 담는 부분 ex) 사용자(웹 브라우저)에서 서버의 응답 데이터를 처리하는 방식 및 형식에 대한 정보, 서버에서 사용자를 식별하기 위한 쿠키 발급 정보 등 Content-Type: 서버의 응답 데이터를 웹 브라우저에서 처리할 방식과 형식 Content-Length: 서버가 사용자에게 응답해주는 데이터의 길이 Server: 서버가 사용하는 소프트웨어의 정보 Allow: 허용되는 Method 목록을 사용자에게 알려줄 때 사용 LocationL 300번 영역의 응답 코드 사용 시 변경된 웹 리소스의 주소 Set-Cookie 사용자에게 쿠키를 발급할 때 사용 해당 헤더를 받은 웹 브라우저는 해당 쿠키를 저장 Body: 서버가 사용자에게 응답하는 데이터를 담는 부분" }, { "title": "[Github blog] 깃허브 블로그 포스팅 방법", "url": "/posts/Github-blog-post/", "categories": "Github Blog", "tags": "Blog, jekyll, Github, Git, markdown", "date": "2022-04-28 00:00:00 +0900", "snippet": "Github Blog에 포스팅하는 방법을 까먹지 않고자 해당 게시글을 작성하고자 한다. 해당 포스트에서는 markdown을 사용할 것인데 이를 이용하기 위해선 markdown을 사용할 수 있는 editor가 필요하다. 필자는 포스팅을 위해 Visual Studio Code를 이용했다.에디터를 실행했다면 다음과 같은 과정으로 포스팅을 시작해보자!1. _posts 폴더 생성자신이 만든 Github Blog의 로컬 폴더에 _post 폴더가 있을 것이다. 이 폴더에 들어가자. Github Blog의 로컬 폴더는 Github ID.github.io와 같은 이름을 가지고 있을 것이며, 필자의 Github ID는 DAY0522이므로 필자의 로컬 폴더명은 DAY0522.github.io이다.만약 _post 폴더가 존재하지 않으면 새로 생성해주자.2. _post 폴더에 “yyyy-mm-dd-title.md” 파일을 생성각각의 게시글을 담당할 .md 파일을 작성할 차례다. 각각의 게시글은 .md와 같은 확장자를 가지고 있으며, 각 게시글의 파일명은 yyyy-mm-dd-title과 같이 작성돼야 한다. title에 작성된 내용은 게시글의 URL에 들어가게 된다.ex) 2022-04-28-Github-blog-post.md3. 머리말을 작성하자.앞에서 생성한 .md 파일을 열어 머릿말을 작성할 차례이다. Jekyll은 YAML 형식을 이용하여 머리말을 작성한다. 다음의 코드를 통해 머리말을 작성할 수 있으며, 해당 코드는 YAML 형식의 극히 일부이므로 더 많은 내용을 알고 싶다면 여기 또는 구글링을 통해 확인하도록 하자.---title: \"[Github blog] 깃허브 블로그 포스팅 방법\"excerpt: \"마크다운 문법을 이용해 md파일을 작성하여 Github blog에 포스팅 해보자.\"writer: Dayeong Kimcategories: - Gibhub Blogtags: - [Blog, jekyll, Github, Git, markdown]toc: truetoc_sticky: truedate: 2022-04-28last_modified_at: 2022-04-28---4. Markdown 문법으로 본문을 작성머릿말을 만들었으므로 본문을 작성할 차례이다. 본문은 Markdown 문법에 기초하여 작성자 입맛대로 코드를 작성해나가면 된다.코드만 봐서는 원하는대로 코드가 잘 작성됐는지 확인하는 것이 어려우므로 로컬 서버를 실행하여 작성한 Markdown이 잘 동작하는지 확인하도록 하자.5. Git에 Push하기.md 파일을 모두 작성하고 로컬서버에서 확인했는데도 문제가 없다면 이제 Github Blog에 올릴 차례다. 작성한 .md 파일을 Git Push 하여 원격(Github)에 올려야 한다. 원격 서버에 파일을 올린 후에 조금 기다리면(올라가기까지 어느 정도의 시간이 소요됨) 자신의 Github blog에 포스팅된 것을 확인할 수 있다.해당 포스팅에서 작성한 .md파일의 코드를 참고용으로 공유하고자 한다. 아래 링크에 들어가 Raw로 열어보면 포스팅을 위해 작성한 머리말, 본문 등 코드를 확인할 수 있다.2022-04-28-Github-blog-post.md참고 사이트Markdown 문법 참고Github Blog 포스팅 방법" }, { "title": "[Spring] A problem occurred configuring root project '...' 에러 해결 ", "url": "/posts/spring-error/", "categories": "Spring", "tags": "Spring, Spring Boot, 스프링, 스프링부트, Java, 백엔드, backend, 에러", "date": "2022-02-10 00:00:00 +0900", "snippet": "Spring Initializr를 통해 Spring 프로젝트 파일을 생성하고, build.gradle을 실행하면 다음과 같은 오류가 발생할 때가 있다.A problem occurred configuring root project '...'이유는 Spring boot 3.x 버전은 JAVA 17부터 지원을 하는데, IntelliJ에서 JAVA 버전이 11로 설정되어 있었기 때문이다.다음과 같이 설정을 변경함으로써 에러를 해결할 수 있었다. Ctrl+Shift+Alt+S를 눌러 JAVA를 17로 변경 File &gt; Settings &gt; Build, Execution, Deployment &gt; Build Tools &gt; Gradle에서 Gradle JVM의 버전을 JAVA 17로 변경" } ]
